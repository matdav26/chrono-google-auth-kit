from fastapi import APIRouter, UploadFile, File, HTTPException, Depends, Request, Form, Response
from app.services.summarize import generate_summary
from app.utils.file_parser import parse_file
from app.services.supabase_client import supabase, fetch_project_context
# RAG imports moved to .rag_hidden/ directory
# from app.services.rag_indexer import index_single_project, reindex_pending_embeddings
# RAG imports moved to .rag_hidden/ directory
# from app.services.rag_retriever import search_and_generate
from app.auth import get_current_user  # ‚úÖ Auth dependency
import traceback
from pathlib import Path
from app.auth import bearer_scheme
from fastapi.security import HTTPAuthorizationCredentials
from uuid import UUID
from fastapi.responses import RedirectResponse
import os
from datetime import datetime


router = APIRouter()

# ‚ö†Ô∏è TESTING ONLY: Service key authentication helper
# This should be removed or disabled in production
SERVICE_KEY = os.getenv("SUPABASE_SERVICE_KEY")

def is_service_key_auth(auth_header: str) -> bool:
    """Check if the authorization header matches the service key"""
    print("DEBUG - Incoming auth header:", repr(auth_header))
    print("DEBUG - Expected service key:", repr(SERVICE_KEY))
    print("DEBUG - Auth header length:", len(auth_header))
    print("DEBUG - Service key length:", len(SERVICE_KEY) if SERVICE_KEY else 0)
    
    # Check raw token format
    raw_match = auth_header == SERVICE_KEY
    print("DEBUG - Raw token match:", raw_match)
    
    # Check bearer token format
    bearer_match = auth_header == f"Bearer {SERVICE_KEY}"
    print("DEBUG - Bearer token match:", bearer_match)
    
    result = raw_match or bearer_match
    print("DEBUG - Final result:", result)
    
    return result

# RAG Search Endpoint
@router.post("/projects/{project_id}/rag-search")
async def rag_search(
    project_id: str,
    request: Request
):
    """
    Search RAG context for relevant information using semantic search
    
    ‚ö†Ô∏è TESTING ONLY: This endpoint accepts Supabase service role key for local testing.
    This should be removed or disabled in production.
    """
    try:
        # ‚ö†Ô∏è TESTING ONLY: Check for service role key authentication FIRST
        # This allows testing with service key without user JWT tokens
        # Accepts both raw token and Bearer token formats
        # REMOVE THIS IN PRODUCTION
        auth_header = request.headers.get("Authorization", "")
        
        # Use the debug function to check service key authentication
        is_service_key_auth_result = is_service_key_auth(auth_header)
        
        if is_service_key_auth_result:
            print("üîë Using service role key authentication for testing")
            # Skip user authentication and project access check for service key
            pass
        else:
            # Normal user authentication flow - try to get user from JWT
            try:
                from app.auth import get_current_user
                user_id = get_current_user(request)
            except:
                raise HTTPException(status_code=401, detail="Invalid authentication")
            
            # Check if user has access to this project
            access_check = supabase.table("project_memberships") \
                .select("*") \
                .eq("user_id", user_id) \
                .eq("project_id", project_id) \
                .execute()

            if not access_check.data:
                raise HTTPException(status_code=403, detail="Unauthorized access to project")

        # Get query from request body
        body = await request.json()
        query = body.get("query", "").strip()
        match_count = body.get("match_count", 5)
        
        if not query:
            raise HTTPException(status_code=400, detail="Query is required")

        # Validate match_count
        if not isinstance(match_count, int) or match_count < 1 or match_count > 20:
            match_count = 5  # Default to 5 if invalid

        # Search RAG context and generate answer using the new function
        search_result = search_and_generate(project_id, query, match_count)
        
        return {
            "project_id": project_id,
            "query": query,
            "match_count": match_count,
            "results": search_result["results"],
            "answer": search_result["answer"],
            "total_results": search_result["total_results"]
        }
        
    except HTTPException:
        raise
    except Exception as e:
        print(f"‚ùå Error in rag_search: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")

# RAG Project Context Endpoint
@router.get("/projects/{project_id}/context")
async def get_project_context(
    project_id: str,
    user_id: str = Depends(get_current_user)
):
    """
    Get unified project context for RAG chatbot
    """
    try:
        # Check if user has access to this project
        access_check = supabase.table("project_memberships") \
            .select("*") \
            .eq("user_id", user_id) \
            .eq("project_id", project_id) \
            .execute()

        if not access_check.data:
            raise HTTPException(status_code=403, detail="Unauthorized access to project")

        # Fetch project context from unified view
        context = fetch_project_context(project_id)
        
        if context is None:
            raise HTTPException(status_code=500, detail="Failed to fetch project context")
        
        if not context:
            return {
                "project_id": project_id,
                "message": "No context found for this project.",
                "context": []
            }
        
        return {
            "project_id": project_id,
            "context": context,
            "total_items": len(context)
        }
        
    except HTTPException:
        raise
    except Exception as e:
        print(f"‚ùå Error in get_project_context: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")

# RAG Indexing Endpoint
@router.post("/projects/{project_id}/index-rag")
async def index_project_rag(
    project_id: str,
    request: Request
):
    """
    Index project content for RAG embeddings
    
    ‚ö†Ô∏è TESTING ONLY: This endpoint accepts Supabase service role key for local testing.
    This should be removed or disabled in production.
    """
    try:
        print(f"üöÄ Starting index_project_rag for project: {project_id}")
        
        # ‚ö†Ô∏è TESTING ONLY: Check for service role key authentication FIRST
        # This allows testing with service key without user JWT tokens
        # Accepts both raw token and Bearer token formats
        # REMOVE THIS IN PRODUCTION
        auth_header = request.headers.get("Authorization", "")
        
        # Use the debug function to check service key authentication
        is_service_key_auth_result = is_service_key_auth(auth_header)
        print(f"üîç Service key auth result: {is_service_key_auth_result}")
        
        if is_service_key_auth_result:
            print("üîë Using service role key authentication for testing")
            # Skip user authentication and project access check for service key
            pass
        else:
            print("üë§ Falling back to user authentication")
            # Normal user authentication flow - try to get user from JWT
            try:
                from app.auth import get_current_user
                user_id = get_current_user(request)
                print(f"‚úÖ User authenticated: {user_id}")
            except Exception as e:
                print(f"‚ùå User authentication failed: {e}")
                raise HTTPException(status_code=401, detail="Invalid authentication")
            
            # Validate project access for the current user
            access_check = supabase.table("project_memberships") \
                .select("*") \
                .eq("user_id", user_id) \
                .eq("project_id", project_id) \
                .execute()

            if not access_check.data:
                print(f"‚ùå User {user_id} has no access to project {project_id}")
                raise HTTPException(status_code=403, detail="Unauthorized access to project")

        print(f"üìû Calling index_project_for_rag for project: {project_id}")
        # Call index_project_for_rag(project_id)
        result = index_project_for_rag(project_id)
        print(f"üìä Index result: {result}")
        
        if result["success"]:
            return {
                "indexed_count": result["indexed_count"],
                "project_id": project_id,
                "success": True,
                "total_items": result.get("total_items", 0),
                "errors": result.get("errors", [])
            }
        else:
            raise HTTPException(
                status_code=500, 
                detail=f"Failed to index project: {result.get('error', 'Unknown error')}"
            )
            
    except HTTPException:
        print("‚ùå HTTPException raised in index_project_rag")
        raise
    except Exception as e:
        print(f"‚ùå Unexpected error in index_project_rag: {e}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail="Internal server error")

@router.post("/projects/{project_id}/update-rag")
async def update_project_rag(
    project_id: str,
    user_id: str = Depends(get_current_user)
):
    """
    Update RAG index when project content changes
    """
    try:
        # Check if user has access to this project
        access_check = supabase.table("project_memberships") \
            .select("*") \
            .eq("user_id", user_id) \
            .eq("project_id", project_id) \
            .execute()

        if not access_check.data:
            raise HTTPException(status_code=403, detail="Unauthorized access to project")

        # Update RAG index
        success = update_project_rag_index(project_id)
        
        if success:
            return {
                "project_id": project_id,
                "message": "RAG index updated successfully",
                "status": "success"
            }
        else:
            raise HTTPException(status_code=500, detail="Failed to update RAG index")
            
    except HTTPException:
        raise
    except Exception as e:
        print(f"‚ùå Error in update_project_rag: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")

@router.post("/projects/{project_id}/search-rag")
async def search_project_rag(
    project_id: str,
    request: Request,
    user_id: str = Depends(get_current_user)
):
    """
    Search RAG context for relevant information
    """
    try:
        # Check if user has access to this project
        access_check = supabase.table("project_memberships") \
            .select("*") \
            .eq("user_id", user_id) \
            .eq("project_id", project_id) \
            .execute()

        if not access_check.data:
            raise HTTPException(status_code=403, detail="Unauthorized access to project")

        # Get query from request body
        body = await request.json()
        query = body.get("query", "").strip()
        limit = body.get("limit", 5)
        
        if not query:
            raise HTTPException(status_code=400, detail="Query is required")

        # Search RAG context
        results = search_rag_context(project_id, query, limit)
        
        return {
            "project_id": project_id,
            "query": query,
            "results": results,
            "total_results": len(results)
        }
        
    except HTTPException:
        raise
    except Exception as e:
        print(f"‚ùå Error in search_project_rag: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")

# OAuth callback endpoints
@router.get("/auth/callback")
async def auth_callback(code: str, state: str = None, error: str = None):
    """
    Handle OAuth callback from Supabase Auth
    """
    if error:
        # Handle OAuth error
        return RedirectResponse(url=f"/login?error={error}")
    
    try:
        # Exchange code for session
        session_response = supabase.auth.exchange_code_for_session(code)
        
        if session_response.session:
            # Successful authentication
            access_token = session_response.session.access_token
            refresh_token = session_response.session.refresh_token
            user = session_response.user
            
            # Redirect to frontend with tokens
            redirect_url = os.getenv("FRONTEND_URL", "http://localhost:3000")
            return RedirectResponse(
                url=f"{redirect_url}/auth-success?access_token={access_token}&refresh_token={refresh_token}&user_id={user.id}"
            )
        else:
            return RedirectResponse(url="/login?error=authentication_failed")
            
    except Exception as e:
        print(f"‚ùå OAuth callback error: {str(e)}")
        return RedirectResponse(url="/login?error=callback_failed")

@router.get("/auth/session")
async def get_session(request: Request):
    """
    Get current session information
    """
    try:
        auth_header = request.headers.get("Authorization")
        if not auth_header or not auth_header.startswith("Bearer "):
            raise HTTPException(status_code=401, detail="No valid authorization header")
        
        token = auth_header.split(" ")[1]
        user = supabase.auth.get_user(token)
        
        return {
            "user": user.user,
            "session": user.session
        }
    except Exception as e:
        raise HTTPException(status_code=401, detail="Invalid session")

@router.post("/auth/logout")
async def logout(request: Request):
    """
    Logout user and invalidate session
    """
    try:
        auth_header = request.headers.get("Authorization")
        if auth_header and auth_header.startswith("Bearer "):
            token = auth_header.split(" ")[1]
            supabase.auth.sign_out(token)
        
        return {"message": "Logged out successfully"}
    except Exception as e:
        print(f"‚ùå Logout error: {str(e)}")
        return {"message": "Logged out successfully"}


@router.post("/upload/")
async def upload_file(file: UploadFile = File(...)):
    try:
        text = parse_file(file.filename)
        summary = generate_summary(text)
        action_items = []  # Placeholder

        return {
            "filename": file.filename,
            "summary": summary,
            "action_items": action_items
        }

    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/test-projects")
def list_projects():
    response = supabase.table("projects").select("*").execute()
    return response.data


@router.get("/projects/")
def get_projects_for_user(
    request: Request,
    user_id: str = Depends(get_current_user)
):
    auth_header = request.headers.get("Authorization")
    print("üîê Received Authorization header:", auth_header)
    
    memberships = supabase.table("project_memberships") \
        .select("project_id") \
        .eq("user_id", user_id) \
        .execute()

    project_ids = [m["project_id"] for m in memberships.data]

    if not project_ids:
        return []

    projects = supabase.table("projects") \
        .select("*") \
        .in_("id", project_ids) \
        .execute()

    return projects.data

@router.get("/projects/{project_id}/documents/")
def get_documents(
    project_id: str,
    request: Request,
    user_id: str = Depends(get_current_user)
):  # ‚úÖ Secure route

    print("‚úÖ user_id from token:", user_id)
    auth_header = request.headers.get("Authorization")
    print("üìÑ Docs auth header:", auth_header)

    access_check = supabase.table("project_memberships") \
        .select("*") \
        .eq("user_id", user_id) \
        .eq("project_id", project_id) \
        .execute()

    if not access_check.data:
        raise HTTPException(status_code=403, detail="Unauthorized")

    docs = supabase.table("documents") \
        .select("*") \
        .eq("project_id", project_id) \
        .execute()

    return docs.data

@router.post("/projects/{project_id}/documents/")
async def upload_document_to_project(
    request: Request,
    project_id: str,
    file: UploadFile = File(...),
    user_id: str = Depends(get_current_user)
):
    try:
        if not user_id:
            raise HTTPException(status_code=401, detail="Failed to extract user ID")

        # Authorization
        access = supabase.table("project_memberships") \
            .select("role") \
            .eq("user_id", user_id) \
            .eq("project_id", project_id) \
            .execute()

        if not access.data or access.data[0]["role"] not in ["editor", "owner"]:
            raise HTTPException(status_code=403, detail="Unauthorized")

        # File validation
        allowed_extensions = [".pdf", ".docx", ".txt"]
        ext = Path(file.filename).suffix.lower()
        if ext not in allowed_extensions:
            raise HTTPException(status_code=400, detail="Unsupported file type")

        file_bytes = await file.read()
        max_size_mb = 10
        if len(file_bytes) > max_size_mb * 1024 * 1024:
            raise HTTPException(status_code=400, detail="File too large")

        # Parse file (no automatic summary generation)
        text = parse_file(file.filename, file_bytes)
        summary = None
        processed = False

        # Save to Supabase storage
        from uuid import uuid4
        unique_filename = f"{uuid4()}_{file.filename}"
        storage_path = f"{project_id}/{unique_filename}"
        full_storage_path = f"documents/{storage_path}"  # Include bucket name
        download_path = unique_filename  # Just the filename for downloads
        
        print(f"üìÅ Storage path: {storage_path}")  # Add this line to see the path
        print(f"üìÅ Full storage path: {full_storage_path}")  # Add this line to see the full path
        print(f"üìÅ Download path: {download_path}")  # Add this line to see the download path

        supabase.storage.from_("documents").upload(storage_path, file_bytes)
        public_url = supabase.storage.from_("documents").get_public_url(storage_path)

        # Insert into documents table
        doc_insert = supabase.table("documents").insert({
            "project_id": project_id,
            "filename": file.filename,
            "doc_type": "file",
            "raw_text": text,
            "summary": summary,
            "processed": processed,  # Set based on whether summary was generated
            "storage_path": full_storage_path,  # Store the full storage path with bucket name
            "download_path": download_path,  # Store the download path (just filename)
            # REMOVE these if not in schema:
            # "public_url": public_url,
        }).execute()

        return {
            "message": "Document uploaded successfully",
            "document_id": doc_insert.data[0]["id"],
            "summary": summary
        }

    except Exception as e:
        # Optional: delete orphaned file if upload succeeded
        if "storage_path" in locals():
            try:
                supabase.storage.from_("documents").remove([storage_path])
            except Exception as cleanup_err:
                print("‚ö†Ô∏è Failed to cleanup storage:", cleanup_err)

        print("‚ùå Exception during upload:", str(e))
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/documents/{document_id}/generate-summary")
async def generate_document_summary(
    document_id: str,
    user_id: str = Depends(get_current_user)
):
    try:
        # Get the document
        doc_response = supabase.table("documents").select("*").eq("id", document_id).execute()
        
        if not doc_response.data:
            raise HTTPException(status_code=404, detail="Document not found")
        
        document = doc_response.data[0]
        
        # Check if user has access to the project
        access = supabase.table("project_memberships") \
            .select("role") \
            .eq("user_id", user_id) \
            .eq("project_id", document["project_id"]) \
            .execute()

        if not access.data or access.data[0]["role"] not in ["editor", "owner"]:
            raise HTTPException(status_code=403, detail="Unauthorized")

        # Check if document already has a summary
        if document.get("summary") and document.get("processed"):
            return {
                "message": "Document already has a summary",
                "summary": document["summary"]
            }

        # Get the file from storage and generate summary
        storage_path = document.get("storage_path")
        print(f"üîç Looking for file at: {storage_path}")  # Add this line
        print(f"üìÑ Document data: {document}")  # Add this line to see full document
        if not storage_path:
            raise HTTPException(status_code=404, detail="Storage path not found for document")
        
        try:
            # Download file from storage
            # Remove "documents/" prefix for the download call
            download_path = storage_path.replace("documents/", "")
            print(f"üîç Download path: {download_path}")  # Add this line
            file_response = supabase.storage.from_("documents").download(download_path)
            print(f"üìÅ File response type: {type(file_response)}")  # Add this line
            
            # Handle the response - it might be bytes directly or have a .data attribute
            if hasattr(file_response, 'data'):
                file_bytes = file_response.data
            else:
                file_bytes = file_response  # Direct bytes response
                
            if not file_bytes:
                raise HTTPException(status_code=404, detail="File not found in storage")
            
            # Parse and summarize
            text = parse_file(document['filename'], file_bytes)
            summary = generate_summary(text)
            
            # Update document with summary
            supabase.table("documents").update({
                "summary": summary,
                "processed": True
            }).eq("id", document_id).execute()
            
            return {
                "message": "Summary generated successfully",
                "summary": summary
            }
        
        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Failed to process file: {str(e)}")

    except Exception as e:
        print("‚ùå Exception during summary generation:", str(e))
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/events/{event_id}/generate-summary")
async def generate_event_summary(
    event_id: str,
    user_id: str = Depends(get_current_user)
):
    try:
        print(f"üîç Looking for event with ID: {event_id}")
        # Get the event
        event_response = supabase.table("events").select("*").eq("id", event_id).execute()
        
        print(f"üìÑ Event response: {event_response.data}")
        if not event_response.data:
            raise HTTPException(status_code=404, detail="Event not found")
        
        event = event_response.data[0]
        
        # Check if user has access to the project
        access = supabase.table("project_memberships") \
            .select("role") \
            .eq("user_id", user_id) \
            .eq("project_id", event["project_id"]) \
            .execute()

        if not access.data or access.data[0]["role"] not in ["editor", "owner"]:
            raise HTTPException(status_code=403, detail="Unauthorized")

        # Check if event already has a summary
        if event.get("event_summary") and event.get("processed"):
            return {
                "message": "Event already has a summary",
                "summary": event["event_summary"]
            }

        # Generate summary from event description
        event_description = event.get("event_description", "")
        event_name = event.get("event_name", "")
        
        if not event_description:
            # If no description, create a summary based on just the event name
            prompt = f"""
            Event Name: {event_name}
            
            Please provide a concise summary of this event in 1-2 sentences based on the event name.
            """
        else:
            # Create a prompt for event summarization with description
            prompt = f"""
            Event Name: {event_name}
            Event Description: {event_description}
            
            Please provide a concise summary of this event in 2-3 sentences, highlighting the key points and any important details.
            """
        
        summary = generate_summary(prompt)
        
        # Update event with summary
        supabase.table("events").update({
            "event_summary": summary,
            "processed": True
        }).eq("id", event_id).execute()
        
        return {
            "message": "Event summary generated successfully",
            "summary": summary
        }
        
    except Exception as e:
        print("‚ùå Exception during event summary generation:", str(e))
        print("üîç Full traceback:")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/debug/events/{event_id}")
async def debug_event_exists(event_id: str):
    """Debug endpoint to check if an event exists in the database"""
    try:
        print(f"üîç Debug: Looking for event with ID: {event_id}")
        event_response = supabase.table("events").select("*").eq("id", event_id).execute()
        print(f"üìÑ Debug: Event response: {event_response.data}")
        
        if event_response.data:
            return {
                "exists": True,
                "event": event_response.data[0]
            }
        else:
            return {
                "exists": False,
                "message": "Event not found in database"
            }
    except Exception as e:
        return {
            "exists": False,
            "error": str(e)
        }

@router.get("/debug/events")
async def debug_list_all_events():
    """Debug endpoint to list all events in the database"""
    try:
        print("üîç Debug: Fetching all events from database")
        events_response = supabase.table("events").select("*").execute()
        print(f"üìÑ Debug: Found {len(events_response.data)} events")
        
        return {
            "total_events": len(events_response.data),
            "events": events_response.data
        }
    except Exception as e:
        return {
            "error": str(e),
            "total_events": 0,
            "events": []
        }

@router.get("/debug/auth")
async def debug_auth(request: Request):
    """
    Debug endpoint to check authentication state
    """
    auth_header = request.headers.get("Authorization")
    
    debug_info = {
        "has_auth_header": bool(auth_header),
        "auth_header": auth_header[:50] + "..." if auth_header and len(auth_header) > 50 else auth_header,
        "cookies": dict(request.cookies),
        "headers": dict(request.headers)
    }
    
    if auth_header and auth_header.startswith("Bearer "):
        try:
            token = auth_header.split(" ")[1]
            user = supabase.auth.get_user(token)
            debug_info["user"] = user.user
            debug_info["session"] = user.session
            debug_info["token_valid"] = True
        except Exception as e:
            debug_info["token_valid"] = False
            debug_info["token_error"] = str(e)
    
    return debug_info

# Event CRUD Endpoints
@router.post("/events")
async def create_event(
    request: Request
):
    """
    Create a new event
    
    ‚ö†Ô∏è TESTING ONLY: This endpoint accepts Supabase service role key for local testing.
    This should be removed or disabled in production.
    """
    try:
        # ‚ö†Ô∏è TESTING ONLY: Check for service role key authentication FIRST
        auth_header = request.headers.get("Authorization", "")
        is_service_key_auth_result = is_service_key_auth(auth_header)
        
        if is_service_key_auth_result:
            print("üîë Using service role key authentication for testing")
            pass
        else:
            # Normal user authentication flow
            try:
                from app.auth import get_current_user
                user_id = get_current_user(request)
            except:
                raise HTTPException(status_code=401, detail="Invalid authentication")

        # Get event data from request body
        body = await request.json()
        event_name = body.get("event_name", "").strip()
        event_description = body.get("event_description", "").strip()
        project_id = body.get("project_id")
        event_date = body.get("event_date")
        
        if not event_name:
            raise HTTPException(status_code=400, detail="Event name is required")
        
        if not project_id:
            raise HTTPException(status_code=400, detail="Project ID is required")

        # Create event in database
        event_data = {
            "event_name": event_name,
            "event_description": event_description,
            "project_id": project_id,
            "event_date": event_date,
            "created_at": datetime.now().isoformat()
        }
        
        response = supabase.table("events").insert(event_data).execute()
        
        if response.data:
            created_event = response.data[0]
            print(f"‚úÖ Created event: {created_event['id']} - {event_name}")
            
            
            return {
                "success": True,
                "event": created_event,
                "message": "Event created successfully"
            }
        else:
            raise HTTPException(status_code=500, detail="Failed to create event")
            
    except HTTPException:
        raise
    except Exception as e:
        print(f"‚ùå Error creating event: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")

@router.get("/events/{event_id}")
async def get_event(
    event_id: str,
    request: Request
):
    """
    Get a specific event by ID
    
    ‚ö†Ô∏è TESTING ONLY: This endpoint accepts Supabase service role key for local testing.
    This should be removed or disabled in production.
    """
    try:
        # ‚ö†Ô∏è TESTING ONLY: Check for service role key authentication FIRST
        auth_header = request.headers.get("Authorization", "")
        is_service_key_auth_result = is_service_key_auth(auth_header)
        
        if is_service_key_auth_result:
            print("üîë Using service role key authentication for testing")
            pass
        else:
            # Normal user authentication flow
            try:
                from app.auth import get_current_user
                user_id = get_current_user(request)
            except:
                raise HTTPException(status_code=401, detail="Invalid authentication")

        # Get event from database
        response = supabase.table("events").select("*").eq("id", event_id).execute()
        
        if response.data:
            event = response.data[0]
            return {
                "success": True,
                "event": event
            }
        else:
            raise HTTPException(status_code=404, detail="Event not found")
            
    except HTTPException:
        raise
    except Exception as e:
        print(f"‚ùå Error getting event: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")

@router.put("/events/{event_id}")
async def update_event(
    event_id: str,
    request: Request
):
    """
    Update an existing event
    
    ‚ö†Ô∏è TESTING ONLY: This endpoint accepts Supabase service role key for local testing.
    This should be removed or disabled in production.
    """
    try:
        # ‚ö†Ô∏è TESTING ONLY: Check for service role key authentication FIRST
        auth_header = request.headers.get("Authorization", "")
        is_service_key_auth_result = is_service_key_auth(auth_header)
        
        if is_service_key_auth_result:
            print("üîë Using service role key authentication for testing")
            pass
        else:
            # Normal user authentication flow
            try:
                from app.auth import get_current_user
                user_id = get_current_user(request)
            except:
                raise HTTPException(status_code=401, detail="Invalid authentication")

        # Get update data from request body
        body = await request.json()
        update_data = {}
        
        if "event_name" in body:
            update_data["event_name"] = body["event_name"].strip()
        if "event_description" in body:
            update_data["event_description"] = body["event_description"].strip()
        if "event_date" in body:
            update_data["event_date"] = body["event_date"]
        
        if not update_data:
            raise HTTPException(status_code=400, detail="No update data provided")

        # Update event in database
        response = supabase.table("events").update(update_data).eq("id", event_id).execute()
        
        if response.data:
            updated_event = response.data[0]
            project_id = updated_event.get("project_id")
            print(f"‚úÖ Updated event: {event_id}")
            
            
            return {
                "success": True,
                "event": updated_event,
                "message": "Event updated successfully"
            }
        else:
            raise HTTPException(status_code=404, detail="Event not found")
            
    except HTTPException:
        raise
    except Exception as e:
        print(f"‚ùå Error updating event: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")

@router.delete("/events/{event_id}")
async def delete_event(
    event_id: str,
    request: Request
):
    """
    Delete an event
    
    ‚ö†Ô∏è TESTING ONLY: This endpoint accepts Supabase service role key for local testing.
    This should be removed or disabled in production.
    """
    try:
        # ‚ö†Ô∏è TESTING ONLY: Check for service role key authentication FIRST
        auth_header = request.headers.get("Authorization", "")
        is_service_key_auth_result = is_service_key_auth(auth_header)
        
        if is_service_key_auth_result:
            print("üîë Using service role key authentication for testing")
            pass
        else:
            # Normal user authentication flow
            try:
                from app.auth import get_current_user
                user_id = get_current_user(request)
            except:
                raise HTTPException(status_code=401, detail="Invalid authentication")

        # Get the event first to get the project_id before deletion
        event_response = supabase.table("events").select("project_id").eq("id", event_id).execute()
        if not event_response.data:
            raise HTTPException(status_code=404, detail="Event not found")
        
        project_id = event_response.data[0].get("project_id")

        # Delete event from database
        response = supabase.table("events").delete().eq("id", event_id).execute()
        
        if response.data:
            print(f"‚úÖ Deleted event: {event_id}")
            
            
            return {
                "success": True,
                "message": "Event deleted successfully"
            }
        else:
            raise HTTPException(status_code=404, detail="Event not found")
            
    except HTTPException:
        raise
    except Exception as e:
        print(f"‚ùå Error deleting event: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")

@router.get("/projects/{project_id}/events")
async def get_project_events(
    project_id: str,
    request: Request
):
    """
    Get all events for a specific project
    
    ‚ö†Ô∏è TESTING ONLY: This endpoint accepts Supabase service role key for local testing.
    This should be removed or disabled in production.
    """
    try:
        # ‚ö†Ô∏è TESTING ONLY: Check for service role key authentication FIRST
        auth_header = request.headers.get("Authorization", "")
        is_service_key_auth_result = is_service_key_auth(auth_header)
        
        if is_service_key_auth_result:
            print("üîë Using service role key authentication for testing")
            pass
        else:
            # Normal user authentication flow
            try:
                from app.auth import get_current_user
                user_id = get_current_user(request)
            except:
                raise HTTPException(status_code=401, detail="Invalid authentication")

        # Get events for project from database
        response = supabase.table("events").select("*").eq("project_id", project_id).order("created_at", desc=True).execute()
        
        events = response.data or []
        print(f"‚úÖ Retrieved {len(events)} events for project {project_id}")
        
        return {
            "success": True,
            "events": events,
            "count": len(events)
        }
            
    except HTTPException:
        raise
    except Exception as e:
        print(f"‚ùå Error getting project events: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")

# Action Item CRUD Endpoints
@router.post("/action-items")
async def create_action_item(
    request: Request
):
    """
    Create a new action item
    
    ‚ö†Ô∏è TESTING ONLY: This endpoint accepts Supabase service role key for local testing.
    This should be removed or disabled in production.
    """
    try:
        # ‚ö†Ô∏è TESTING ONLY: Check for service role key authentication FIRST
        auth_header = request.headers.get("Authorization", "")
        is_service_key_auth_result = is_service_key_auth(auth_header)
        
        if is_service_key_auth_result:
            print("üîë Using service role key authentication for testing")
            pass
        else:
            # Normal user authentication flow
            try:
                from app.auth import get_current_user
                user_id = get_current_user(request)
            except:
                raise HTTPException(status_code=401, detail="Invalid authentication")

        # Get action item data from request body
        body = await request.json()
        action_name = body.get("action_name", "").strip()
        description = body.get("description", "").strip()
        project_id = body.get("project_id")
        deadline = body.get("deadline")
        status = body.get("status", "open")
        
        if not action_name:
            raise HTTPException(status_code=400, detail="Action name is required")
        
        if not project_id:
            raise HTTPException(status_code=400, detail="Project ID is required")

        # Create action item in database
        action_data = {
            "action_name": action_name,
            "description": description,
            "project_id": project_id,
            "deadline": deadline,
            "status": status,
            "created_at": datetime.now().isoformat()
        }
        
        response = supabase.table("action_items").insert(action_data).execute()
        
        if response.data:
            created_action = response.data[0]
            print(f"‚úÖ Created action item: {created_action['id']} - {action_name}")
            
            
            return {
                "success": True,
                "action_item": created_action,
                "message": "Action item created successfully"
            }
        else:
            raise HTTPException(status_code=500, detail="Failed to create action item")
            
    except HTTPException:
        raise
    except Exception as e:
        print(f"‚ùå Error creating action item: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")

@router.get("/action-items/{action_item_id}")
async def get_action_item(
    action_item_id: str,
    request: Request
):
    """
    Get a specific action item by ID
    
    ‚ö†Ô∏è TESTING ONLY: This endpoint accepts Supabase service role key for local testing.
    This should be removed or disabled in production.
    """
    try:
        # ‚ö†Ô∏è TESTING ONLY: Check for service role key authentication FIRST
        auth_header = request.headers.get("Authorization", "")
        is_service_key_auth_result = is_service_key_auth(auth_header)
        
        if is_service_key_auth_result:
            print("üîë Using service role key authentication for testing")
            pass
        else:
            # Normal user authentication flow
            try:
                from app.auth import get_current_user
                user_id = get_current_user(request)
            except:
                raise HTTPException(status_code=401, detail="Invalid authentication")

        # Get action item from database
        response = supabase.table("action_items").select("*").eq("id", action_item_id).execute()
        
        if response.data:
            action_item = response.data[0]
            return {
                "success": True,
                "action_item": action_item
            }
        else:
            raise HTTPException(status_code=404, detail="Action item not found")
            
    except HTTPException:
        raise
    except Exception as e:
        print(f"‚ùå Error getting action item: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")

@router.put("/action-items/{action_item_id}")
async def update_action_item(
    action_item_id: str,
    request: Request
):
    """
    Update an existing action item
    
    ‚ö†Ô∏è TESTING ONLY: This endpoint accepts Supabase service role key for local testing.
    This should be removed or disabled in production.
    """
    try:
        # ‚ö†Ô∏è TESTING ONLY: Check for service role key authentication FIRST
        auth_header = request.headers.get("Authorization", "")
        is_service_key_auth_result = is_service_key_auth(auth_header)
        
        if is_service_key_auth_result:
            print("üîë Using service role key authentication for testing")
            pass
        else:
            # Normal user authentication flow
            try:
                from app.auth import get_current_user
                user_id = get_current_user(request)
            except:
                raise HTTPException(status_code=401, detail="Invalid authentication")

        # Get update data from request body
        body = await request.json()
        update_data = {}
        
        if "action_name" in body:
            update_data["action_name"] = body["action_name"].strip()
        if "description" in body:
            update_data["description"] = body["description"].strip()
        if "deadline" in body:
            update_data["deadline"] = body["deadline"]
        if "status" in body:
            update_data["status"] = body["status"]
        
        if not update_data:
            raise HTTPException(status_code=400, detail="No update data provided")

        # Update action item in database
        response = supabase.table("action_items").update(update_data).eq("id", action_item_id).execute()
        
        if response.data:
            updated_action = response.data[0]
            project_id = updated_action.get("project_id")
            print(f"‚úÖ Updated action item: {action_item_id}")
            
            
            return {
                "success": True,
                "action_item": updated_action,
                "message": "Action item updated successfully"
            }
        else:
            raise HTTPException(status_code=404, detail="Action item not found")
            
    except HTTPException:
        raise
    except Exception as e:
        print(f"‚ùå Error updating action item: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")

@router.delete("/action-items/{action_item_id}")
async def delete_action_item(
    action_item_id: str,
    request: Request
):
    """
    Delete an action item
    
    ‚ö†Ô∏è TESTING ONLY: This endpoint accepts Supabase service role key for local testing.
    This should be removed or disabled in production.
    """
    try:
        # ‚ö†Ô∏è TESTING ONLY: Check for service role key authentication FIRST
        auth_header = request.headers.get("Authorization", "")
        is_service_key_auth_result = is_service_key_auth(auth_header)
        
        if is_service_key_auth_result:
            print("üîë Using service role key authentication for testing")
            pass
        else:
            # Normal user authentication flow
            try:
                from app.auth import get_current_user
                user_id = get_current_user(request)
            except:
                raise HTTPException(status_code=401, detail="Invalid authentication")

        # Get the action item first to get the project_id before deletion
        action_response = supabase.table("action_items").select("project_id").eq("id", action_item_id).execute()
        if not action_response.data:
            raise HTTPException(status_code=404, detail="Action item not found")
        
        project_id = action_response.data[0].get("project_id")

        # Delete action item from database
        response = supabase.table("action_items").delete().eq("id", action_item_id).execute()
        
        if response.data:
            print(f"‚úÖ Deleted action item: {action_item_id}")
            
            
            return {
                "success": True,
                "message": "Action item deleted successfully"
            }
        else:
            raise HTTPException(status_code=404, detail="Action item not found")
            
    except HTTPException:
        raise
    except Exception as e:
        print(f"‚ùå Error deleting action item: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")

@router.get("/projects/{project_id}/action-items")
async def get_project_action_items(
    project_id: str,
    request: Request
):
    """
    Get all action items for a specific project
    
    ‚ö†Ô∏è TESTING ONLY: This endpoint accepts Supabase service role key for local testing.
    This should be removed or disabled in production.
    """
    try:
        # ‚ö†Ô∏è TESTING ONLY: Check for service role key authentication FIRST
        auth_header = request.headers.get("Authorization", "")
        is_service_key_auth_result = is_service_key_auth(auth_header)
        
        if is_service_key_auth_result:
            print("üîë Using service role key authentication for testing")
            pass
        else:
            # Normal user authentication flow
            try:
                from app.auth import get_current_user
                user_id = get_current_user(request)
            except:
                raise HTTPException(status_code=401, detail="Invalid authentication")

        # Get action items for project from database
        response = supabase.table("action_items").select("*").eq("project_id", project_id).order("created_at", desc=True).execute()
        
        action_items = response.data or []
        print(f"‚úÖ Retrieved {len(action_items)} action items for project {project_id}")
        
        return {
            "success": True,
            "action_items": action_items,
            "count": len(action_items)
        }
            
    except HTTPException:
        raise
    except Exception as e:
        print(f"‚ùå Error getting project action items: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")

# RAG Reindex Pending Embeddings Endpoint
@router.post("/rag/reindex-pending")
async def reindex_pending_embeddings_endpoint(
    request: Request
):
    """
    Reindex pending embeddings for rows that have NULL embedding values.
    This endpoint processes any content that was inserted but doesn't have
    embeddings generated yet.
    
    ‚ö†Ô∏è TESTING ONLY: This endpoint accepts Supabase service role key for local testing.
    This should be removed or disabled in production.
    """
    try:
        print(f"üöÄ Starting reindex_pending_embeddings endpoint...")
        
        auth_header = request.headers.get("Authorization", "")
        is_service_key_auth_result = is_service_key_auth(auth_header)
        print(f"üîç Service key auth result: {is_service_key_auth_result}")
        
        if is_service_key_auth_result:
            print("üîë Using service role key authentication for testing")
            pass
        else:
            print("üë§ Falling back to user authentication")
            try:
                from app.auth import get_current_user
                user_id = get_current_user(request)
                print(f"‚úÖ User authenticated: {user_id}")
            except Exception as e:
                print(f"‚ùå User authentication failed: {e}")
                raise HTTPException(status_code=401, detail="Invalid authentication")

        print(f"üìû Calling reindex_pending_embeddings...")
        # RAG imports moved to .rag_hidden/ directory
# from app.services.rag_indexer import reindex_pending_embeddings
        result = reindex_pending_embeddings()
        print(f"üìä Reindex result: {result}")
        
        if result["success"]:
            return {
                "processed_count": result["processed_count"],
                "errors": result.get("errors", []),
                "success": True,
                "total_pending": result.get("total_pending", 0),
                "message": result.get("message", "Reindex completed successfully")
            }
        else:
            raise HTTPException(
                status_code=500, 
                detail=f"Failed to reindex pending embeddings: {result.get('errors', ['Unknown error'])}"
            )
            
    except HTTPException:
        print("‚ùå HTTPException raised in reindex_pending_embeddings_endpoint")
        raise
    except Exception as e:
        print(f"‚ùå Unexpected error in reindex_pending_embeddings_endpoint: {e}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail="Internal server error")


